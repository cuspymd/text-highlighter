크롬 익스텐션 파일 구조:

1. manifest.json - 익스텐션 기본 정보 및 설정
2. background.js - 백그라운드 스크립트
3. content.js - 웹페이지에 주입되는 스크립트 
4. popup.html - 팝업 UI 인터페이스
5. popup.js - 팝업 동작 스크립트
6. styles.css - 스타일시트

각 파일의 코드를 순서대로 작성하겠습니다.

------------------------
manifest.json:
------------------------

{
  "manifest_version": 3,
  "name": "Text Highlighter",
  "version": "1.0",
  "description": "웹페이지에서 텍스트를 선택하고 색상으로 마킹할 수 있는 확장 프로그램",
  "permissions": [
    "storage", 
    "contextMenus",
    "activeTab"
  ],
  "background": {
    "service_worker": "background.js"
  },
  "action": {
    "default_popup": "popup.html",
    "default_icon": {
      "16": "images/icon16.png",
      "48": "images/icon48.png",
      "128": "images/icon128.png"
    }
  },
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["content.js"],
      "css": ["styles.css"]
    }
  ],
  "icons": {
    "16": "images/icon16.png",
    "48": "images/icon48.png",
    "128": "images/icon128.png"
  }
}

------------------------
background.js:
------------------------

// 콘텍스트 메뉴 아이템 생성
const COLORS = [
  { id: 'yellow', name: '노란색', color: '#FFFF00' },
  { id: 'green', name: '초록색', color: '#AAFFAA' },
  { id: 'blue', name: '파란색', color: '#AAAAFF' },
  { id: 'pink', name: '분홍색', color: '#FFAAFF' },
  { id: 'orange', name: '주황색', color: '#FFAA55' }
];

// 익스텐션이 설치되거나 업데이트될 때 콘텍스트 메뉴 생성
chrome.runtime.onInstalled.addListener(() => {
  // 상위 메뉴 항목 생성
  chrome.contextMenus.create({
    id: 'highlight-text',
    title: '텍스트 하이라이트',
    contexts: ['selection']
  });

  // 색상 하위메뉴 생성
  COLORS.forEach(color => {
    chrome.contextMenus.create({
      id: `highlight-${color.id}`,
      parentId: 'highlight-text',
      title: color.name,
      contexts: ['selection']
    });
  });

  // 하이라이트 제거 메뉴 항목 추가
  chrome.contextMenus.create({
    id: 'remove-highlight',
    parentId: 'highlight-text',
    title: '하이라이트 제거',
    contexts: ['selection']
  });
});

// 컨텍스트 메뉴 클릭 처리
chrome.contextMenus.onClicked.addListener((info, tab) => {
  const menuId = info.menuItemId;
  console.log('Context menu clicked:', menuId);
  
  if (menuId.startsWith('highlight-') && menuId !== 'highlight-text') {
    const colorId = menuId.replace('highlight-', '');
    const color = COLORS.find(c => c.id === colorId);
    
    if (color) {
      console.log('Sending highlight action to tab:', tab.id);
      chrome.tabs.sendMessage(tab.id, {
        action: 'highlight',
        color: color.color,
        text: info.selectionText
      }, response => {
        console.log('Highlight action response:', response);
      });
    }
  } 
  else if (menuId === 'remove-highlight') {
    console.log('Sending remove highlight action to tab:', tab.id);
    chrome.tabs.sendMessage(tab.id, {
      action: 'removeHighlight',
      text: info.selectionText
    }, response => {
      console.log('Remove highlight action response:', response);
    });
  }
});

// 콘텐츠 스크립트와 통신
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.action === 'getHighlights') {
    // 현재 URL에 대한 하이라이트 정보 가져오기
    chrome.storage.local.get([message.url], (result) => {
      sendResponse({ highlights: result[message.url] || [] });
    });
    return true;
  }
  
  if (message.action === 'saveHighlights') {
    // 현재 URL에 대한 하이라이트 정보 저장
    const saveData = {};
    saveData[message.url] = message.highlights;
    chrome.storage.local.set(saveData, () => {
      sendResponse({ success: true });
    });
    return true;
  }
});

------------------------
content.js:
------------------------

// 현재 웹페이지의 하이라이트 데이터를 저장할 배열
let highlights = [];
const currentUrl = window.location.href;

// 페이지 로드 시 저장된 하이라이트 정보 불러오기
// DOMContentLoaded 대신 즉시 실행
console.log('Content script loaded for:', currentUrl);
loadHighlights();

// 백업으로 DOMContentLoaded 이벤트 리스너도 유지
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOMContentLoaded event fired');
  loadHighlights();
});

// 백그라운드에서 메시지 수신 처리
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.action === 'highlight') {
    highlightSelectedText(message.color);
  }
  else if (message.action === 'removeHighlight') {
    removeHighlight();
  }
  else if (message.action === 'refreshHighlights') {
    // 팝업에서 하이라이트 정보가 업데이트되었을 때 처리
    console.log('Refreshing highlights:', message.highlights);
    highlights = message.highlights || [];
    clearAllHighlights();
    applyHighlights();
    return true;
  }
});

// 저장된 하이라이트 불러오기
function loadHighlights() {
  console.log('Loading highlights for URL:', currentUrl);
  chrome.runtime.sendMessage(
    { action: 'getHighlights', url: currentUrl },
    (response) => {
      console.log('Got highlights response:', response);
      if (response && response.highlights) {
        highlights = response.highlights;
        console.log('Applying highlights:', highlights.length);
        applyHighlights();
      } else {
        console.log('No highlights found or invalid response');
      }
    }
  );
}

// 하이라이트 저장하기
function saveHighlights() {
  chrome.runtime.sendMessage(
    { action: 'saveHighlights', url: currentUrl, highlights: highlights },
    (response) => {
      console.log('Highlights saved:', response.success);
    }
  );
}

// 선택된 텍스트 하이라이트 처리
function highlightSelectedText(color) {
  const selection = window.getSelection();
  
  if (!selection.rangeCount) return;
  
  const range = selection.getRangeAt(0);
  const selectionContents = range.extractContents();
  const span = document.createElement('span');
  
  span.appendChild(selectionContents);
  span.className = 'text-highlighter-extension';
  span.style.backgroundColor = color;
  span.dataset.highlightId = Date.now().toString();
  
  range.insertNode(span);
  
  // 하이라이트 정보 저장
  highlights.push({
    id: span.dataset.highlightId,
    text: span.textContent,
    color: color,
    xpath: getXPathForElement(span),
    textRange: {
      startOffset: range.startOffset,
      endOffset: range.endOffset
    }
  });
  
  saveHighlights();
  selection.removeAllRanges();
}

// 하이라이트 제거
function removeHighlight() {
  const selection = window.getSelection();
  
  if (!selection.rangeCount) return;
  
  const range = selection.getRangeAt(0);
  let highlightSpan = null;
  
  // 현재 선택된 텍스트가 하이라이트된 요소 내부인지 확인
  let node = range.commonAncestorContainer;
  
  while (node) {
    if (node.nodeType === Node.ELEMENT_NODE && 
        node.classList.contains('text-highlighter-extension')) {
      highlightSpan = node;
      break;
    }
    node = node.parentNode;
  }
  
  if (highlightSpan) {
    const parent = highlightSpan.parentNode;
    while (highlightSpan.firstChild) {
      parent.insertBefore(highlightSpan.firstChild, highlightSpan);
    }
    
    // highlights 배열에서 해당 항목 제거
    const highlightId = highlightSpan.dataset.highlightId;
    highlights = highlights.filter(h => h.id !== highlightId);
    
    // 요소 제거 및 저장
    parent.removeChild(highlightSpan);
    saveHighlights();
    selection.removeAllRanges();
  }
}

// 페이지의 모든 하이라이트 제거
function clearAllHighlights() {
  console.log('Clearing all highlights');
  const highlightElements = document.querySelectorAll('.text-highlighter-extension');
  highlightElements.forEach(element => {
    const parent = element.parentNode;
    while (element.firstChild) {
      parent.insertBefore(element.firstChild, element);
    }
    parent.removeChild(element);
  });
}

// 저장된 하이라이트 정보로 페이지에 적용
function applyHighlights() {
  console.log('Applying highlights, count:', highlights.length);
  highlights.forEach(highlight => {
    try {
      // 텍스트 기반 검색 시도
      console.log('Applying highlight:', highlight.text);
      const textFound = highlightTextInDocument(
        document.body, 
        highlight.text, 
        highlight.color, 
        highlight.id
      );
      
      if (!textFound) {
        console.log('Text not found by content, trying XPath');
        // XPath 기반 찾기 시도
        const element = getElementByXPath(highlight.xpath);
        if (element) {
          const textNode = findTextNodeByContent(element, highlight.text);
          
          if (textNode) {
            const span = document.createElement('span');
            span.textContent = highlight.text;
            span.className = 'text-highlighter-extension';
            span.style.backgroundColor = highlight.color;
            span.dataset.highlightId = highlight.id;
            
            // 텍스트 노드를 하이라이트 요소로 대체
            textNode.parentNode.replaceChild(span, textNode);
            console.log('Highlight applied via XPath');
          }
        }
      }
    } catch (error) {
      console.error('Error applying highlight:', error);
    }
  });
}

// 문서 내에서 텍스트를 찾아 하이라이트 적용
function highlightTextInDocument(element, text, color, id) {
  if (!text || text.length < 3) return false; // 너무 짧은 텍스트는 건너뛰기
  
  const walker = document.createTreeWalker(
    element,
    NodeFilter.SHOW_TEXT,
    {
      acceptNode: function(node) {
        // 이미 하이라이트된 요소의 자식은 건너뛰기
        if (node.parentNode.className === 'text-highlighter-extension') {
          return NodeFilter.FILTER_REJECT;
        }
        // script, style 태그 내부는 건너뛰기
        if (['SCRIPT', 'STYLE', 'NOSCRIPT'].includes(node.parentNode.tagName)) {
          return NodeFilter.FILTER_REJECT;
        }
        return NodeFilter.FILTER_ACCEPT;
      }
    },
    false
  );
  
  let found = false;
  let node;
  
  while ((node = walker.nextNode()) && !found) {
    const content = node.textContent;
    const index = content.indexOf(text);
    
    if (index >= 0) {
      // 텍스트 발견
      const range = document.createRange();
      range.setStart(node, index);
      range.setEnd(node, index + text.length);
      
      const span = document.createElement('span');
      span.className = 'text-highlighter-extension';
      span.style.backgroundColor = color;
      span.dataset.highlightId = id;
      
      range.surroundContents(span);
      found = true;
      console.log('Text found and highlighted:', text);
      
      // Walker를 무효화했으므로 루프 종료
      break;
    }
  }
  
  return found;
}

// 텍스트 내용으로 텍스트 노드 찾기
function findTextNodeByContent(element, text) {
  const walker = document.createTreeWalker(
    element,
    NodeFilter.SHOW_TEXT,
    null,
    false
  );
  
  let node;
  while ((node = walker.nextNode())) {
    if (node.textContent.includes(text)) {
      return node;
    }
  }
  
  return null;
}

// XPath로 요소 가져오기
function getElementByXPath(xpath) {
  return document.evaluate(
    xpath, 
    document, 
    null, 
    XPathResult.FIRST_ORDERED_NODE_TYPE, 
    null
  ).singleNodeValue;
}

// 요소의 XPath 생성
function getXPathForElement(element) {
  if (element.tagName === 'HTML') {
    return '/HTML[1]';
  }
  if (element === document.body) {
    return '/HTML[1]/BODY[1]';
  }
  
  let ix = 0;
  const siblings = element.parentNode.childNodes;
  
  for (let i = 0; i < siblings.length; i++) {
    const sibling = siblings[i];
    
    if (sibling === element) {
      const pathIndex = ix + 1;
      const path = getXPathForElement(element.parentNode) + 
                  '/' + element.tagName + '[' + pathIndex + ']';
      return path;
    }
    
    if (sibling.nodeType === 1 && sibling.tagName === element.tagName) {
      ix++;
    }
  }
}

------------------------
popup.html:
------------------------

<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>텍스트 하이라이터</title>
  <style>
    body {
      width: 300px;
      padding: 15px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }
    
    h1 {
      font-size: 18px;
      margin-top: 0;
      margin-bottom: 15px;
      text-align: center;
    }
    
    .section {
      margin-bottom: 20px;
    }
    
    .color-selector {
      display: flex;
      justify-content: space-between;
      margin-bottom: 15px;
    }
    
    .color-item {
      width: 30px;
      height: 30px;
      border-radius: 15px;
      cursor: pointer;
      border: 2px solid transparent;
    }
    
    .color-item.selected {
      border-color: #000;
    }
    
    .btn {
      width: 100%;
      padding: 8px;
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      border-radius: 4px; 
      cursor: pointer;
      font-size: 14px;
      margin-bottom: 8px;
    }
    
    .btn:hover {
      background-color: #e0e0e0;
    }
    
    .highlights-list {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 8px;
      margin-top: 10px;
    }
    
    .highlight-item {
      padding: 5px;
      margin-bottom: 5px;
      border-radius: 3px;
      position: relative;
    }
    
    .delete-btn {
      position: absolute;
      right: 5px;
      top: 5px;
      cursor: pointer;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>텍스트 하이라이터</h1>
  
  <div class="section">
    <p>웹 페이지에서 텍스트를 선택한 후 마우스 오른쪽 버튼을 클릭하여 하이라이트할 수 있습니다.</p>
  </div>
  
  <div class="section">
    <h2>현재 페이지 하이라이트</h2>
    <div id="highlights-container" class="highlights-list">
      <div id="no-highlights">현재 페이지에 하이라이트된 텍스트가 없습니다.</div>
    </div>
  </div>
  
  <div class="section">
    <button id="clear-all" class="btn">모든 하이라이트 지우기</button>
    <button id="export-data" class="btn">하이라이트 내보내기</button>
  </div>
  
  <script src="popup.js"></script>
</body>
</html>

------------------------
popup.js:
------------------------

document.addEventListener('DOMContentLoaded', function() {
  const highlightsContainer = document.getElementById('highlights-container');
  const noHighlights = document.getElementById('no-highlights');
  const clearAllBtn = document.getElementById('clear-all');
  const exportDataBtn = document.getElementById('export-data');
  
  // 현재 활성화된 탭에서 하이라이트 정보 불러오기
  function loadHighlights() {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      const currentUrl = tabs[0].url;
      
      chrome.storage.local.get([currentUrl], (result) => {
        const highlights = result[currentUrl] || [];
        
        // 하이라이트 목록 표시
        if (highlights.length > 0) {
          noHighlights.style.display = 'none';
          highlightsContainer.innerHTML = '';
          
          highlights.forEach(highlight => {
            const highlightItem = document.createElement('div');
            highlightItem.className = 'highlight-item';
            highlightItem.style.backgroundColor = highlight.color;
            highlightItem.dataset.id = highlight.id;
            
            // 텍스트가 너무 길면 자르기
            let displayText = highlight.text;
            if (displayText.length > 50) {
              displayText = displayText.substring(0, 47) + '...';
            }
            
            highlightItem.textContent = displayText;
            
            // 삭제 버튼 추가
            const deleteBtn = document.createElement('span');
            deleteBtn.className = 'delete-btn';
            deleteBtn.textContent = '×';
            deleteBtn.addEventListener('click', function(e) {
              e.stopPropagation();
              deleteHighlight(highlight.id, currentUrl);
            });
            
            highlightItem.appendChild(deleteBtn);
            highlightsContainer.appendChild(highlightItem);
          });
        } else {
          noHighlights.style.display = 'block';
          highlightsContainer.innerHTML = '';
          highlightsContainer.appendChild(noHighlights);
        }
      });
    });
  }
  
  // 하이라이트 삭제
  function deleteHighlight(id, url) {
    chrome.storage.local.get([url], (result) => {
      const highlights = result[url] || [];
      const updatedHighlights = highlights.filter(h => h.id !== id);
      
      const saveData = {};
      saveData[url] = updatedHighlights;
      
      chrome.storage.local.set(saveData, () => {
        // 현재 페이지의 하이라이트 업데이트
        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
          chrome.tabs.sendMessage(tabs[0].id, { 
            action: 'refreshHighlights',
            highlights: updatedHighlights
          });
        });
        
        loadHighlights();
      });
    });
  }
  
  // 모든 하이라이트 삭제
  clearAllBtn.addEventListener('click', function() {
    if (confirm('정말 현재 페이지의 모든 하이라이트를 삭제하시겠습니까?')) {
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        const currentUrl = tabs[0].url;
        
        const saveData = {};
        saveData[currentUrl] = [];
        
        chrome.storage.local.set(saveData, () => {
          // 현재 페이지의 하이라이트 업데이트
          chrome.tabs.sendMessage(tabs[0].id, { 
            action: 'refreshHighlights',
            highlights: []
          });
          
          loadHighlights();
        });
      });
    }
  });
  
  // 하이라이트 데이터 내보내기
  exportDataBtn.addEventListener('click', function() {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      const currentUrl = tabs[0].url;
      
      chrome.storage.local.get([currentUrl], (result) => {
        const highlights = result[currentUrl] || [];
        
        // 내보낼 데이터 생성
        const exportData = {
          url: currentUrl,
          title: tabs[0].title,
          date: new Date().toISOString(),
          highlights: highlights
        };
        
        // 파일로 다운로드
        const blob = new Blob([JSON.stringify(exportData, null, 2)], {
          type: 'application/json'
        });
        
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'highlights-' + new Date().getTime() + '.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });
    });
  });
  
  // 페이지 로드 시 하이라이트 목록 표시
  loadHighlights();
});

------------------------
styles.css:
------------------------

.text-highlighter-extension {
  display: inline;
  border-radius: 2px;
  padding: 0 1px;
  margin: 0 1px;
  cursor: pointer;
  position: relative;
}

.text-highlighter-extension:hover {
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.2);
}
